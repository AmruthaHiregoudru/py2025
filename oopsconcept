#Encapsulation

# class bikes:
#     def perf(self):
#         print("gt","650cc",15,4)
# gt=bikes()
# duke=bikes()
# gt.perf()
# duke.perf()

#############
# class bikes:
#     def __init__(self,name,cc,m,cost):
#         self.name=name
#         self.cc=cc
#         self.m=m
#         self.cost=cost
#     def perf(self):
#         print("abt bikes:",self.name,self.cc,self.m,self.cost)
# gt =bikes("gt",650,12,4)
# duke=bikes("duke",390,30,2)
# gt.perf()
# duke.perf()

##class method and static method
# class cars:
#     wheels=4
#     def __init__(self,mil,car):
#         self.mil=mil
#         self.car=car
#     def get_mil(self):
#         return c1.mil
#     def set_mil(self):
#         c1.mil=12
#     @staticmethod
#     def info():
#         print("hi hello")
#     @classmethod
#     def infor(cls):
#         return cls.wheels
# print(cars.infor())
# c1=cars(10,"BMW")
# c2=cars(15,"audi")
# c1.wheels=9
# print(c1.mil)
# print(c1.wheels)
# print(c2.wheels)
# print(c1.get_mil())
# print(c1.set_mil())
# print(c1.mil)

##polymorphism(overriding)
# class pycharm:
#     def execute(self):
#         print("compiling")
#         print("running")
# class myeditor:
#     def execute(self):
#         print("debugging")
#         print("printing error")
#         print("compiling")
#         print("running")
# class laptop:
#     def code(self,ide):
#         ide.execute()
# ide=pycharm()
# lap1=laptop()
# lap1.code(ide)

##
# a=4
# b=6
# print(a+b)
# print(init.__add__(a,b))
#operator overloading
# class student:
#     def __init__(self,m1,m2):
#         self.m1=m1
#         self.m2=m2
#     def __add__(self,other):
#         m1=self.m1+other.m1
#         m2=self.m2+other.m2
#         s3=student(m1,m2)
#         return s3
#     def __gt__(self,other):
#         r1=self.m1+self.m2
#         r2=other.m1+other.m2
#         if r1>r2:
#             return True
#         else:
#             return False
# s1=student(59,65)
# s2=student(67,85)
# s3=s1+s2
# print(s3.m1)
# print(s3.m2)
# if s1>s2:
#     print("s1 is having more marks than s2")
# else:
#     print("s2 is having more marks than s1")

#method overloading
# class math:
#     def add(self,a=0,b=0,c=0):
#         return a+b+c
# m=math()
# print(m.add(1,2))
# print(m.add(1,2,3))
# print(m.add())

##single-level inheritance
# class Animal:
#     def sound(self):
#         return "Animals make different sounds"
# class Dog(Animal):
#     def sound(self):
#         return "dog barks"
# d=Dog()
# print(d.sound())           ##overiding

#multiple inheritance
# class engine:
#     def engine_info(self):
#         return "this is an engine"
# class wheels:
#     def wheels_info(self):
#         return "car has 4 wheels"
# class car(engine,wheels):
#     def car_info(self):
#         return "this is a car"
# c=car()
# print(c.engine_info())
# print(c.wheels_info())
# print(c.car_info())

#multilevel inheritance
# class Animal:
#     def species(self):
#         return "this is an animal"
# class Mammal(Animal):
#     def category(self):
#         return "this is a mammal"
# class Human(Mammal):
#     def speak(self):
#         return "human can speak"
# h=Human()
# print(h.species())
# print(h.category())
# print(h.speak())

#hierachical inheritance
# class vehicle:
#     def fuel_type(self):
#         return "vehicles can use petrol,diesel and lpg"
# class car(vehicle):
#     def type(self):
#         return "car is a 4-wheeler"
# class bike(vehicle):
#     def type(self):
#         return "bike is a 2-wheeler"
# c=car()
# b=bike()
# print(c.fuel_type())
# print(c.type())
# print(b.type())

##hybrid inheritance
class a:
    def display(self):
        return "hi"
class b(a):
    def display(self):
        return "hello"
class c:
    def show(self):
        return "ohh"
class d(b,c):
    def display(self):
        return "woww"
d1=d()
d1.display()
d1.show()
print(d.mro()) ##method resolution order(mro)